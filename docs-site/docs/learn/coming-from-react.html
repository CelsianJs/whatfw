<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coming from React — What Framework</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles.css">
  <script src="../../theme.js"></script>
  <script src="../copy-code.js"></script>
</head>
<body>
  <nav>
    <div class="nav-left">
      <a href="../" class="logo">What <span class="logo-badge">v0.5.5</span></a>
      <div class="nav-links">
        <a href="./" class="active">Learn</a>
        <a href="../reference/">Reference</a>
        <a href="../tutorial/">Tutorial</a>
      </div>
    </div>
    <div class="nav-right">
      <button class="theme-toggle" aria-label="Toggle theme">
        <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
        <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
      </button>
    </div>
  </nav>

  <div class="layout">
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Get Started</div>
        <ul class="sidebar-links">
          <li><a href="./">Quick Start</a></li>
          <li><a href="./coming-from-react.html" class="active">Coming from React</a></li>
          <li><a href="./signals.html">Signals</a></li>
          <li><a href="./components.html">Components</a></li>
        </ul>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-links">
          <li><a href="./effects.html">Effects</a></li>
          <li><a href="./control-flow.html">Control Flow</a></li>
          <li><a href="./lifecycle.html">Lifecycle</a></li>
          <li><a href="./context.html">Context</a></li>
        </ul>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-title">Data &amp; State</div>
        <ul class="sidebar-links">
          <li><a href="./data-fetching.html">Data Fetching</a></li>
          <li><a href="./forms.html">Forms</a></li>
          <li><a href="./stores.html">Stores</a></li>
        </ul>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-title">Navigation &amp; Caching</div>
        <ul class="sidebar-links">
          <li><a href="./routing.html">Routing</a></li>
          <li><a href="./caching.html">Caching</a></li>
        </ul>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-title">Advanced</div>
        <ul class="sidebar-links">
          <li><a href="./islands.html">Islands</a></li>
          <li><a href="./ssr.html">Server Rendering</a></li>
          <li><a href="./animation.html">Animation</a></li>
          <li><a href="./accessibility.html">Accessibility</a></li>
        </ul>
      </div>
    </aside>

    <main class="content">
      <div class="content-wrapper">
        <div class="content-inner">
          <h1>Coming from React</h1>
          <p class="subtitle">If you know React, you already know most of What. This page covers the key differences so you can be productive immediately.</p>

          <h2 id="the-big-difference">The Big Difference: No Re-Renders</h2>

          <p>In React, when state changes, the <strong>entire component function re-runs</strong>. Every variable is recalculated, every expression is re-evaluated, and React diffs a virtual DOM to figure out what changed.</p>

          <p>In What, component functions run <strong>once</strong>. Signals update the specific DOM nodes that depend on them — no virtual DOM, no diffing, no re-running the whole function.</p>

          <p>This is faster, but it means some React patterns don't translate directly.</p>

          <h2 id="state">State: useState vs useSignal</h2>

          <table>
            <thead>
              <tr>
                <th>React</th>
                <th>What</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>const [x, setX] = useState(0)</code></td>
                <td><code>const x = useSignal(0)</code></td>
              </tr>
              <tr>
                <td><code>x</code> (read)</td>
                <td><code>x()</code> (read — call it like a function)</td>
              </tr>
              <tr>
                <td><code>setX(5)</code></td>
                <td><code>x.set(5)</code></td>
              </tr>
              <tr>
                <td><code>setX(prev =&gt; prev + 1)</code></td>
                <td><code>x.set(prev =&gt; prev + 1)</code></td>
              </tr>
            </tbody>
          </table>

<pre><code><span class="comment">// React</span>
<span class="keyword">function</span> <span class="function">Counter</span>() {
  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);
  <span class="keyword">return</span> &lt;button onClick={() =&gt; setCount(c =&gt; c + <span class="number">1</span>)}&gt;{count}&lt;/button&gt;;
}

<span class="comment">// What</span>
<span class="keyword">function</span> <span class="function">Counter</span>() {
  <span class="keyword">const</span> count = <span class="function">useSignal</span>(<span class="number">0</span>);
  <span class="keyword">return</span> &lt;button onClick={() =&gt; count.set(c =&gt; c + <span class="number">1</span>)}&gt;{count()}&lt;/button&gt;;
}</code></pre>

          <h2 id="derived-values">Derived Values: Why useComputed Exists</h2>

          <p>This is the #1 thing that trips up React developers.</p>

          <p>In React, <code>const doubled = count * 2</code> just works because the whole function re-runs on every state change — <code>doubled</code> gets recalculated every time.</p>

          <p>In What, the component function runs <strong>once</strong>. So <code>const doubled = count() * 2</code> evaluates to a plain number at creation time and <strong>never updates</strong>:</p>

<pre><code><span class="comment">// BROKEN — doubled is a dead number, computed once, never updates</span>
<span class="keyword">function</span> <span class="function">App</span>() {
  <span class="keyword">const</span> count = <span class="function">useSignal</span>(<span class="number">0</span>);
  <span class="keyword">const</span> doubled = count() * <span class="number">2</span>;  <span class="comment">// Evaluates to 0, stays 0 forever</span>

  <span class="keyword">return</span> &lt;p&gt;Doubled: {doubled}&lt;/p&gt;;  <span class="comment">// Always shows "Doubled: 0"</span>
}</code></pre>

          <p>Use <code>useComputed</code> to create a derived signal that tracks its dependencies and updates automatically:</p>

<pre><code><span class="comment">// CORRECT — useComputed tracks count and re-derives when it changes</span>
<span class="keyword">function</span> <span class="function">App</span>() {
  <span class="keyword">const</span> count = <span class="function">useSignal</span>(<span class="number">0</span>);
  <span class="keyword">const</span> doubled = <span class="function">useComputed</span>(() =&gt; count() * <span class="number">2</span>);

  <span class="keyword">return</span> &lt;p&gt;Doubled: {doubled()}&lt;/p&gt;;  <span class="comment">// Updates when count changes</span>
}</code></pre>

          <div class="callout callout-info">
            <p class="callout-title">When do you need useComputed?</p>
            <p>If you're computing a value from signals and need to use it in <strong>multiple places</strong> or pass it to child components, use <code>useComputed</code>. It caches the result and only recomputes when dependencies change.</p>
            <p>For simple expressions used only once in JSX, the compiler handles reactivity automatically — <code>{count() * 2}</code> works directly in JSX because the compiler wraps it.</p>
          </div>

          <h3>The rule</h3>

          <table>
            <thead>
              <tr>
                <th>React pattern</th>
                <th>What equivalent</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>const x = a + b</code></td>
                <td><code>const x = useComputed(() =&gt; a() + b())</code></td>
              </tr>
              <tr>
                <td><code>useMemo(() =&gt; expensive(), [dep])</code></td>
                <td><code>useComputed(() =&gt; expensive(dep()))</code></td>
              </tr>
              <tr>
                <td><code>{count * 2}</code> in JSX</td>
                <td><code>{count() * 2}</code> in JSX (compiler handles it)</td>
              </tr>
            </tbody>
          </table>

          <h2 id="set-in-body">Never Call .set() in the Component Body</h2>

          <p>In React, calling <code>setState</code> during render is bad practice but React catches it and shows a warning. In What, it's an <strong>instant infinite loop</strong>:</p>

<pre><code><span class="comment">// INFINITE LOOP — don't do this</span>
<span class="keyword">function</span> <span class="function">Broken</span>() {
  <span class="keyword">const</span> count = <span class="function">useSignal</span>(<span class="number">0</span>);
  count.set(c =&gt; c + <span class="number">1</span>);  <span class="comment">// Signal updates → component re-runs → set again → forever</span>
  <span class="keyword">return</span> &lt;p&gt;{count()}&lt;/p&gt;;
}</code></pre>

          <p>Signal writes always go in one of these places:</p>

<pre><code><span class="comment">// 1. Event handlers</span>
&lt;button onClick={() =&gt; count.set(c =&gt; c + <span class="number">1</span>)}&gt;+1&lt;/button&gt;

<span class="comment">// 2. Effects (for reactive side effects)</span>
<span class="function">effect</span>(() =&gt; {
  <span class="keyword">if</span> (query() &amp;&amp; query().length &gt; <span class="number">2</span>) {
    fetchResults(query());
  }
});

<span class="comment">// 3. onMount (for one-time initialization)</span>
<span class="function">onMount</span>(() =&gt; {
  count.set(parseInt(localStorage.getItem(<span class="string">'count'</span>)) || <span class="number">0</span>);
});</code></pre>

          <h2 id="effects">Effects: Auto-Tracking vs Dependency Arrays</h2>

          <p>React effects require you to list dependencies manually:</p>

<pre><code><span class="comment">// React — you manage the deps array</span>
useEffect(() =&gt; {
  document.title = <span class="string">`Count: ${count}`</span>;
}, [count]);  <span class="comment">// Must list count or it won't re-run</span></code></pre>

          <p>What effects <strong>auto-track</strong> — any signal read inside the effect becomes a dependency automatically:</p>

<pre><code><span class="comment">// What — no deps array needed</span>
<span class="function">effect</span>(() =&gt; {
  document.title = <span class="string">`Count: ${count()}`</span>;
  <span class="comment">// Automatically re-runs when count changes</span>
  <span class="comment">// No dependency array — tracking is automatic</span>
});</code></pre>

          <div class="callout callout-info">
            <p class="callout-title">What about useEffect?</p>
            <p>What provides <code>useEffect(fn, deps)</code> for React compatibility, but the idiomatic approach is <code>effect(fn)</code> with auto-tracking. You'll never have a stale closure or missing dependency bug again.</p>
          </div>

          <h3>Opting out of tracking</h3>

          <p>Sometimes you want to read a signal without subscribing to it. Use <code>peek()</code> or <code>untrack()</code>:</p>

<pre><code><span class="function">effect</span>(() =&gt; {
  <span class="comment">// Re-runs when count changes, but NOT when multiplier changes</span>
  <span class="keyword">const</span> result = count() * multiplier.peek();
  console.log(result);
});

<span class="comment">// Or with untrack()</span>
<span class="function">effect</span>(() =&gt; {
  <span class="keyword">const</span> result = count() * <span class="function">untrack</span>(() =&gt; multiplier());
  console.log(result);
});</code></pre>

          <p><code>peek()</code> is shorthand for reading one signal. <code>untrack()</code> wraps a block of code where nothing inside creates subscriptions.</p>

          <h2 id="lifecycle">Lifecycle: onMount vs useEffect(fn, [])</h2>

          <p>In React, "run once on mount" is <code>useEffect(() =&gt; {}, [])</code>. In What, use <code>onMount</code>:</p>

          <table>
            <thead>
              <tr>
                <th>React</th>
                <th>What</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>useEffect(fn, [])</code></td>
                <td><code>onMount(fn)</code></td>
              </tr>
              <tr>
                <td><code>useEffect(() =&gt; { return cleanup }, [])</code></td>
                <td><code>onMount(() =&gt; { return cleanup })</code></td>
              </tr>
              <tr>
                <td><code>useEffect(fn, [dep])</code></td>
                <td><code>effect(fn)</code> (auto-tracks)</td>
              </tr>
              <tr>
                <td>Cleanup on unmount</td>
                <td><code>onCleanup(fn)</code></td>
              </tr>
            </tbody>
          </table>

<pre><code><span class="keyword">import</span> { onMount, onCleanup } <span class="keyword">from</span> <span class="string">'what-framework'</span>;

<span class="keyword">function</span> <span class="function">Chat</span>({ roomId }) {
  <span class="keyword">let</span> socket;

  <span class="function">onMount</span>(() =&gt; {
    socket = <span class="keyword">new</span> WebSocket(<span class="string">`wss://chat.example.com/${roomId}`</span>);
  });

  <span class="function">onCleanup</span>(() =&gt; {
    socket?.close();
  });

  <span class="keyword">return</span> &lt;div&gt;Connected to {roomId}&lt;/div&gt;;
}</code></pre>

          <h2 id="signal-vs-usesignal">signal() vs useSignal()</h2>

          <p>What has two ways to create signals:</p>

          <table>
            <thead>
              <tr>
                <th>API</th>
                <th>Where to use</th>
                <th>Cleanup</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>signal(value)</code></td>
                <td>Anywhere — module scope, outside components, stores</td>
                <td>Manual</td>
              </tr>
              <tr>
                <td><code>useSignal(value)</code></td>
                <td>Inside components only</td>
                <td>Automatic (tied to component lifecycle)</td>
              </tr>
            </tbody>
          </table>

<pre><code><span class="comment">// Module-level signal — shared between all instances, lives forever</span>
<span class="keyword">const</span> theme = <span class="function">signal</span>(<span class="string">'dark'</span>);

<span class="keyword">function</span> <span class="function">Counter</span>() {
  <span class="comment">// Component-level signal — each Counter gets its own, cleaned up on unmount</span>
  <span class="keyword">const</span> count = <span class="function">useSignal</span>(<span class="number">0</span>);

  <span class="keyword">return</span> &lt;button onClick={() =&gt; count.set(c =&gt; c + <span class="number">1</span>)}&gt;{count()}&lt;/button&gt;;
}</code></pre>

          <p>Rule of thumb: use <code>useSignal</code> in components (most of the time), <code>signal</code> for global/shared state.</p>

          <h2 id="quick-reference">Quick Reference</h2>

          <table>
            <thead>
              <tr>
                <th>React</th>
                <th>What</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>useState</code></td>
                <td><code>useSignal</code></td>
                <td>Read with <code>()</code>, write with <code>.set()</code></td>
              </tr>
              <tr>
                <td><code>useMemo</code></td>
                <td><code>useComputed</code></td>
                <td>Auto-tracks, no deps array</td>
              </tr>
              <tr>
                <td><code>useEffect(fn, [deps])</code></td>
                <td><code>effect(fn)</code></td>
                <td>Auto-tracks signals, no deps array</td>
              </tr>
              <tr>
                <td><code>useEffect(fn, [])</code></td>
                <td><code>onMount(fn)</code></td>
                <td>Runs once after first render</td>
              </tr>
              <tr>
                <td><code>useRef</code></td>
                <td><code>useRef</code></td>
                <td>Same API</td>
              </tr>
              <tr>
                <td><code>useCallback</code></td>
                <td>Not needed</td>
                <td>No re-renders means no stale closures</td>
              </tr>
              <tr>
                <td><code>React.memo</code></td>
                <td>Not needed</td>
                <td>Components don't re-render by default</td>
              </tr>
              <tr>
                <td><code>createContext</code></td>
                <td><code>createContext</code></td>
                <td>Same pattern</td>
              </tr>
              <tr>
                <td><code>useContext</code></td>
                <td><code>useContext</code></td>
                <td>Same API</td>
              </tr>
              <tr>
                <td><code>Suspense</code></td>
                <td><code>Suspense</code></td>
                <td>Same pattern</td>
              </tr>
              <tr>
                <td><code>lazy()</code></td>
                <td><code>lazy()</code></td>
                <td>Same API</td>
              </tr>
            </tbody>
          </table>

          <h2 id="common-mistakes">Common Mistakes from React Habits</h2>

          <h3>1. Forgetting to call the signal</h3>
<pre><code><span class="comment">// React habit — count is already a value</span>
&lt;p&gt;{count}&lt;/p&gt;

<span class="comment">// What — count is a function, call it</span>
&lt;p&gt;{count()}&lt;/p&gt;</code></pre>

          <h3>2. Inline math without useComputed</h3>
<pre><code><span class="comment">// React habit — works because component re-runs</span>
<span class="keyword">const</span> doubled = count * <span class="number">2</span>;

<span class="comment">// What — need useComputed for derived values</span>
<span class="keyword">const</span> doubled = <span class="function">useComputed</span>(() =&gt; count() * <span class="number">2</span>);</code></pre>

          <h3>3. Calling .set() in the component body</h3>
<pre><code><span class="comment">// Infinite loop in What</span>
<span class="keyword">function</span> <span class="function">Bad</span>() {
  <span class="keyword">const</span> x = <span class="function">useSignal</span>(<span class="number">0</span>);
  x.set(<span class="number">1</span>);  <span class="comment">// Triggers re-render → set → re-render → forever</span>
  <span class="keyword">return</span> &lt;p&gt;{x()}&lt;/p&gt;;
}

<span class="comment">// Use onMount for initialization</span>
<span class="keyword">function</span> <span class="function">Good</span>() {
  <span class="keyword">const</span> x = <span class="function">useSignal</span>(<span class="number">0</span>);
  <span class="function">onMount</span>(() =&gt; x.set(<span class="number">1</span>));
  <span class="keyword">return</span> &lt;p&gt;{x()}&lt;/p&gt;;
}</code></pre>

          <h3>4. Adding unnecessary dependency arrays</h3>
<pre><code><span class="comment">// React habit — manually listing deps</span>
<span class="function">effect</span>(() =&gt; {
  document.title = count();
}, [count]);  <span class="comment">// ← Not needed, and doesn't do what you think</span>

<span class="comment">// What — just use the signal, tracking is automatic</span>
<span class="function">effect</span>(() =&gt; {
  document.title = count();
});</code></pre>

          <h2 id="react-compat">Using React Libraries in What</h2>

          <p>You don't have to choose between What and the React ecosystem. The <code>what-react</code> compat layer lets you use React libraries (zustand, TanStack Query, Radix UI, and <a href="https://react.whatfw.com">90+ more</a>) directly in What components:</p>

<pre><code><span class="keyword">import</span> { mount, useSignal } <span class="keyword">from</span> <span class="string">'what-framework'</span>;
<span class="keyword">import</span> { create } <span class="keyword">from</span> <span class="string">'zustand'</span>;

<span class="keyword">const</span> useStore = <span class="function">create</span>((set) =&gt; ({
  count: <span class="number">0</span>,
  increment: () =&gt; set((s) =&gt; ({ count: s.count + <span class="number">1</span> })),
}));

<span class="keyword">function</span> <span class="function">App</span>() {
  <span class="keyword">const</span> count = <span class="function">useStore</span>((s) =&gt; s.count);
  <span class="keyword">const</span> increment = <span class="function">useStore</span>((s) =&gt; s.increment);

  <span class="keyword">return</span> &lt;button onClick={increment}&gt;{count}&lt;/button&gt;;
}

<span class="function">mount</span>(&lt;App /&gt;, <span class="string">'#app'</span>);</code></pre>

          <p>See the <a href="https://react.whatfw.com">React Compat docs</a> for setup instructions.</p>

          <div class="page-nav">
            <a href="./">
              <span class="label">Previous</span>
              <span class="title">Quick Start</span>
            </a>
            <a href="./signals.html" class="next">
              <span class="label">Next</span>
              <span class="title">Signals</span>
            </a>
          </div>
        </div>

        <aside class="toc">
          <div class="toc-title">On This Page</div>
          <ul class="toc-links">
            <li><a href="#the-big-difference">The Big Difference</a></li>
            <li><a href="#state">useState vs useSignal</a></li>
            <li><a href="#derived-values">Why useComputed Exists</a></li>
            <li><a href="#set-in-body">Never .set() in Body</a></li>
            <li><a href="#effects">Effects: Auto-Tracking</a></li>
            <li><a href="#lifecycle">onMount vs useEffect</a></li>
            <li><a href="#signal-vs-usesignal">signal() vs useSignal()</a></li>
            <li><a href="#quick-reference">Quick Reference</a></li>
            <li><a href="#common-mistakes">Common Mistakes</a></li>
            <li><a href="#react-compat">React Libraries in What</a></li>
          </ul>
        </aside>
      </div>
    </main>
  </div>
</body>
</html>
